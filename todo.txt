- use haplorec as a git submodule and have it play nice with eclipse
- use a grails plugin (reverse engineer i think) to generate domains from existing haplorec db schema
- generate controllers
- make a draft plan for a web UI for a dependency graph of sql tables (i.e. the job_patient_* tables)
  - try to make an abstract grails module (plugin?) that generates this UI; if too hard, make it adhoc

- try using qunit for unit testing js code ( http://qunitjs.com/ )
  - http://qunitjs.com/intro/
    good examples of testing DOM manipulating code
  - http://qunitjs.com/cookbook/
    good examples of testing ajax code Asynchronous Callbacks
- use jsPlumb for flowcharts ( http://jsplumbtoolkit.com/jquery/flowchartConnectorsDemo.html )
- use dustjs for templating 
  - http://grails.org/plugin/dustjs-resources for compiling dust templates to js 
  - figure out how to configure (i.e. where to put what files)
- use backbonejs for MVC design style
  - http://grails.org/plugin/backbonejs
  - use todo list example for learning backbonejs
- example project using both backbonejs and dustjs ( https://github.com/coderguy/demandware )
  - there seems to be a common pattern for dust template rendering from backbone views; abstract this ( 
    https://github.com/coderguy/demandware/blob/master/app/javascript/backbone/views/HomeView.js )

- fix annoying build problems when trying to import haplorec project into haplorec-wui (kludge it by placing a symbolic link in src/groovy pointing to 
  projects/haplorec/src/)

[o] implement algo for finding level of dependencies in the dependency graph
[o] subclass Depenedency with HaplotypeDependency
[o] convert HaplotypeDependency to JSON (make unit tests)?
  - it mostly works by just importing grails.converters.JSON and doing HaplotypeInput.haplotypeDepedencyGraph() as JSON, we just need to fix a couple things:
    - don't include these fields: class, finished (where'd this come from), rule
    - only want to render dependencies by their target names, not by recursively calling JSON converter
[o] create a backbone model with 1-to-1 correspondence to HaplotypeDependency, and instantiate using JSON data
[o] deserialize the json-ified HaplotypeDependency and load them into backbone models
  - use request.JSON ( http://nematodes.org/martin/2009/12/18/using-jquery-to-send-json-data-to-a-grails-app/, http://grails.org/doc/latest/guide/theWebLayer.html#xmlAndJSON )
[o] create a HaplotypeDependencyGraph model (see notes)
[o] create a HaplotypeDependencyGraphView (see notes)
  - figure out how to use dustjs; if too hard, fallback to underscore
[o] figure out how backbone's notion of collections ties in with how to structure code
- implement file upload feature
  - figure out how to either submit a form using json data from backbone models, or submit things asynchronously
    - http://stackoverflow.com/questions/8156983/submitting-form-via-ajax-request
    - dealing with files in web-apps:
      - https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
      - using backone + FileReader (my concern is that this will not handle large files well, the browser reads the file into memory) http://stackoverflow.com/questions/8171562/backbone-form-with-file-upload-how-to-handle
      - can we use multi-part form submission with a json part and parts for the file contents?
        http://stackoverflow.com/questions/4083702/posting-a-file-and-data-to-restful-webservice-as-json
        http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2
        http://www.html5rocks.com/en/tutorials/file/xhr2/
        (perhaps we can programmatically construct a form for submission on save) https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/FormData
        (sending forms with files programmatically asynchronously using jquery; i think this probably makes the most sense) http://stackoverflow.com/questions/6974684/how-to-send-formdata-objects-with-ajax-requests-in-jquery
        (jquery plugin implementing a nice ui / multi-file selection / drag & drop) https://github.com/blueimp/jQuery-File-Upload
        - don't do crazy asynchronous stuff
        - I think the best approach is:
          - for each dependency node, on-click add an input field with type="file", name="{target}" at the bottom of the form loaded from a dustjs template rendered using the dependency as a model (DependencyUploadView)
          - use client-side javascript w/ web workers for validation / getting info about files
          - call .click() on the input field to open a file dialog box
    - test out posting of data (figure out how we're going to post a file)
  - add on-click file upload functionality to nodes in graph (dialog popup, render file upload thing at bottom)
- figure out how quickly add pages for patient_job tables
  - editting a scaffold generator or something
  - vim macro to make appropriate changes to controller? or just add job and patient param to url?

- looks like removing "display: table-cell" from delete button makes it appear on the same line; what's the deal...?
- onsubmit, ignore input type=file with value undefined / empty
- add digit suffix to input elements of same data type, since web forms just submit 1 file if there are multiple input files with the same name 

- run a sample job that actually generates results
  - figure out how we want to view / download the results

- edit show-job view 
  [o] show the DependencyGraphView extended with counts of the job_* tables
  - when you click on a node it links you to the controller for that table (limited by job_id == whatever id they were looking at)
  - figure out how to minimally change existing job_* list views
  - figure out how to render job_* list views via ajax from job view
  - replace things we want to join (drugRecommendation) with the columns/rows from that particular view
  - does pagination work? (no probably not; can we make it work though?)
    - looks like GORM is returning null objects for jobPatientVariant.forJob(jodId).list(params) for the sample variants.txt file
      - which rows do those nulls correspond to? (which don't they correspond to?)
- handle invalid InvalidInputException (delete rows from job_patient_* tables by calling Job.delete(flush:true))
- handle loading other tables using defaultReader, but disable their loading (only allow loading variants)

- refactor JobPatientDrugRecommendation into 2 identical domains for phenotype / genotype
  - copy domain
  - copy view
  - copy controller
- make sure dependency graph stuff works for 2 base nodes
  - mostly; just need to make node layout vertical order better (phenotype / 
    genotype drug recommendations are laid out poorly)
- implement phenotype / genotype report download
  - add it to the show job view
    - add it to the phenotype / genotype list views??? yeah, it's more abstract that way
    - rename delete button to delete job, and push it farther down
- implement job search using bootstrap-typeahead
  - add tooltip roll-over to nodes in graph and display dependency.description (if non-null)
- add a question mark roll-over to create view, where if you click on the question mark, a modal dialog appears explaining the input source
  - explanation should:
    - show a sample list view of the input source
    - show a sample input file
- edit css files to make list view columns not so squished
- remove links in list views
- make sure sql connections get closed by API

- add spinner when waiting for a job to be created
- make the default page pipelineJob/main
- change headers in report file to match style / names of variants input file
- make g:link's on list pages link to a new page
- make drug links on recommendation pages link to "show drug" page

- make view reference router, so that it can do this.router.navigate('...', {trigger: false}) to record back button history (trigger false is the default)

- bug: back button after selecting a single node doesn't return to a graph with an unselected node
  - router.navigate('/') => view.selectNothing (or something)

- call it novel haplotype, not unique haplotype
- disable input for Haplotypes, Genotypes, and Phenotypes (in web interface only so tests still work)
- novel haplotype report ("take this info and spit out a table that has the haplotypes for each sample")
  - ideally, we'd have the option of outputting the gene-haplotype matrix for a gene, with rows added for the "unknown" haplotypes of a sample (at most 2).
    Since there could be 2, we would want to make the haplotype name "Sample <SAMPLE_ID>, Chromosome <PHYSICAL_CHROMOSOME>"

    e.g.

    G6PD

    Haplotype                      | rs1050828 | rs1050829 | rs5030868 | rs137852328 | rs76723693 | rs2230037
    B (wildtype)                   | C         | T         | G         | C           | A          | G
    A-202A_376G                    | T         | C         | G         | C           | A          | G
    A- 680T_376G                   | C         | C         | G         | A           | A          | G
    A-968C_376G                    | C         | C         | G         | C           | G          | G
    Mediterranean Haplotype        | C         | T         | A         | C           | A          | A
    Sample NA22302-1, Chromosome A | T         | T         | G         |             |            | 
    Sample NA22302-1, Chromosome B | T         | T         | A         |             |            | 
    Sample NA22302-2, Chromosome A | T         | T         | G         |             |            | 
    Sample NA22302-2, Chromosome B | T         | T         | G         |             |            | 

    AnotherGene

    Haplotype                      | rs1050828 | rs1050829 | rs5030868
    B                              | C         | T         | G        
    Sample NA22302-1, Chromosome A | T         | T         | G        
    Sample NA22302-1, Chromosome B | T         | T         | A        
    Sample NA22302-2, Chromosome A | T         | T         | G        
    Sample NA22302-2, Chromosome B | T         | T         | G        

    ...

    NOTE: PharmGKB's ordering of snp's does not seem to be based on the snp name (e.g. under what ordering scheme do you have rs5030868, rs137852328, rs76723693, rs2230037); determine ordering at a 
    later date and just order by snp_id for now...

    novelHaplotypeReport
    input: job_id
    output: 
    an iterable of GeneHaplotypeMatrix where 
    GeneHaplotypeMatrix = (Gene, List<SNP>, List<Haplotype OR NovelHaplotype, List<Allele>>)
    Haplotype = (HaplotypeName)
    NovelHaplotype = (SampleID, PhysicalChromosome)
    Allele = String (possibly null)
    SNP = String (possibly null)

Don't join against gene_snp to get records with null alleles since it leads to a lot of superfluous 
and unnecessary rows. A GeneHaplotypeMatrix class can always provide an iterable interface that 
fills in the null's without the overhead of materializing them in memory.

i.e. don't do this:

select job_id, gene_name, gene_snp_table.snp_id, patient_id, physical_chromosome
from job_patient_unique_haplotype
join job_patient_variant using (job_id, patient_id, physical_chromosome)
right join gene_snp_table using (gene_name)
order by job_id, gene_name, gene_snp_table.snp_id, patient_id, physical_chromosome

instead, do this:

select job_id, gene_name, snp_id, allele, patient_id, physical_chromosome
from job_patient_unique_haplotype
join job_patient_variant using (job_id, patient_id, physical_chromosome)
order by job_id, gene_name, snp_id, patient_id, physical_chromosome

select gene_name, haplotype_name, snp_id, allele
from gene_haplotype_variant
order by gene_name, haplotype_name, snp_id

- run new pgx variants file
- merge unique-haplotypes into master
- merge graphprogress (up to to progress [7642caf6353a59512bbbd7cdcc24b84d384ff58d] but before haplotype matrix stuff) into master

- disable input for all but variants node
- change icon from default .ico

documentation:

guidelines:
- what is the feature (from the user's perspective)
- paragraph (as concise as possible) describing how its implemented at a very high level
- what sourcecode files does this feature depend on; for each file:
  - what portion of the feature is this sourcefile responsible for
  - show some blurb of important code from the sourcefile (possibly), and describe what the code does at a 
    high level; this might be a summary of what the comments already say 
    OR
    - just point them in the direction of the important part of that file if its already well described

steps:
1. add inline comments to code you want to document
2. write documentation (follow guidelines above)
3. make a picture to illustrate a concept not already obvious from 1/2

- stefanie
  - incremental pipeline job status updates
    - PipelineJobController.groovy
      - status
    - jsonstream.js
    - pipelineJob/show.gsp


- create makefile with doc target that builds html sphinx documentation
- 
